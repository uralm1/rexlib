package Ural::Deploy::Utils;

use strict;
use warnings;
use v5.12;
#use utf8;
use feature 'state';

use Carp;
use Data::Dumper;

use Rex -feature=>['1.4'];
use Rex::Commands;

use Exporter 'import';
our @EXPORT_OK = qw(remove_dups is_x86
  recursive_search_by_from_hostname recursive_search_by_to_hostname);
our @EXPORT = qw(uci quci insert_autogen_comment check_dev_erebus check_dev router_os);


# ['a','b'] == remove_dups(['a','a','b']);
sub remove_dups {
  my $aref = shift;
  my %seen;
  return [grep { ! $seen{ $_ }++ } @$aref];
}


### Helpers
sub check_dev_erebus {
  my $p = shift;
  die "Parameters argument required!\n" unless $p;

  die "Unsupported operating system!\n" unless operating_system_is('OpenWrt');
  #say "OS version: ".operating_system_version();
  #say "OS release: ".operating_system_release();
  my $os_ver = operating_system_version();
  die "Unsupported firmware version!\n" if $os_ver < 114 || $os_ver > 399;

  die "This configuration script doesn't support operating system assigned to this device $p->{equipment_name} $p->{router_os_name}!\n"
    if router_os($p) !~ /^x86$/i;
  1;
}

# for owrt
sub check_dev {
  my $p = shift;
  die "Parameters argument required!\n" unless $p;

  die "Unsupported operating system!\n" unless operating_system_is('OpenWrt');
  #say "OS version: ".operating_system_version();
  #say "OS release: ".operating_system_release();
  my $os_ver = operating_system_version();
  die "Unsupported firmware version!\n" if $os_ver < 113 || $os_ver > 399;

  die "This configuration script doesn't support operating system assigned to this device $p->{equipment_name} $p->{router_os_name}!\n"
    if router_os($p) =~ /^unsupported$/i;
  1;
}


# 'mips tp-link'|'mips mikrotik'|'x86'|'unsupported' = router_os $params
sub router_os {
  my $p = shift;
  die "Parameters argument required!\n" unless $p;

  my $id = $p->{router_os_id};
  return 'mips tp-link' if $id == 1;
  return 'mips mikrotik' if $id == 7;
  return 'x86' if $id == 2;
  return 'unsupported';
}


sub uci {
  my $cmd = shift;
  my $output = run "uci $cmd", auto_die=>1, timeout=>10;
  say $output if $output;
};

sub quci {
  my $cmd = shift;
  my $output = run "uci -q $cmd", timeout=>10;
  say $output if $output;
};


sub insert_autogen_comment {
  my $file = shift;
  my $autogen_comment = '# This file is autogenerated. All changes will be overwritten!';
  my $output = run "sed -i \'1i $autogen_comment\' $file", timeout=>10;
  say $output if $output;
}


###
sub is_x86 {
  # check kernel architecture
  my %i = get_system_information;
  return ($i{architecture} =~ /(i\d86)|(x86(_64)?)/);
};


###
sub recursive_search_by_from_hostname {
  my ($listref, $hostname, $tun_array_ref, $tun_node_name) = @_;

  state $loop_control = 0;
  die "Wrong tunnels configuration (reqursive infinite loop found).\n" if $loop_control++ >= 30;

  my @tt1 = grep { $_->{from_hostname} eq $hostname } @$tun_array_ref;
  foreach my $hh1 (@tt1) {
    unless ((grep { $_ eq $hh1->{to_ip} } @$listref) || ($hh1->{to_hostname} eq $tun_node_name)) {
      push @$listref, $hh1->{to_ip};
      recursive_search_by_from_hostname($listref, $hh1->{to_hostname}, $tun_array_ref, $tun_node_name);
    }
  }
}


sub recursive_search_by_to_hostname {
  my ($listref, $hostname, $tun_array_ref, $tun_node_name) = @_;

  state $loop_control = 0;
  die "Wrong tunnels configuration (reqursive infinite loop found).\n" if $loop_control++ >= 30;

  my @tt1 = grep { $_->{to_hostname} eq $hostname } @$tun_array_ref;
  foreach my $hh1 (@tt1) {
    unless ((grep { $_ eq $hh1->{from_ip} } @$listref) || ($hh1->{from_hostname} eq $tun_node_name)) {
      push @$listref, $hh1->{from_ip};
      recursive_search_by_to_hostname($listref, $hh1->{from_hostname}, $tun_array_ref, $tun_node_name);
    }
  }
}


1;
