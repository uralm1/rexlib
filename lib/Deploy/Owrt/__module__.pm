package Deploy::Owrt;

use Rex -feature=>['1.3'];
use Data::Dumper;
use File::Basename;
use DBI;
use NetAddr::IP::Lite;

use Ural::Deploy::ReadDB_Owrt qw(read_db);
use Ural::Deploy::Utils qw(recursive_search_by_from_hostname recursive_search_by_to_hostname);

my $def_net = "UWC66";


### Pre-installaion tasks for images
desc "Install perl for Rex, for images<1.9";
task "install_perl", sub {
  my $output = run "opkg install perl perlbase-bytes perlbase-data perlbase-digest perlbase essential perlbase-file perlbase-xsloader";
  say $output;
}, {dont_register => TRUE};

desc "Create openwrt_release, openwrt_version for Rex, for images<1.10";
task "fix_openwrt_detect", sub {
  my $output = run "touch /etc/openwrt_release /etc/openwrt_version";
  say $output;
}, {dont_register => TRUE};


desc "x86 primary configuration: enable login, disable startup failsafe prompt";
task "x86_preconf", sub {
  die "Unsupported operating system!\n" unless operating_system_is('OpenWrt');
  my $os_ver = operating_system_version();
  die "Unsupported firmware version!\n" if ($os_ver < 113 || $os_ver > 113);
  die "Unsupported system architecture!\n" unless is_x86();

  say "Primary x86 configuration started...";
  # enable login on consoles
  say "Activating login on consoles.";
  # check /bin/login
  die "Fatal error: /bin/login is not compiled.\n" unless (is_file("/bin/login"));
  # fix inittab
  sed qr/::askfirst:\/bin\/ash +--login$/, '::askfirst:/bin/login', '/etc/inittab';

  # disable failsafe mode prompt
  say "Disabling failsafe mode prompts.";
  file "/lib/preinit/30_failsafe_wait", ensure=>'absent';
  file "/lib/preinit/99_10_failsafe_login", ensure=>'absent';

  say "Primary x86 configuration finished. Reboot router to apply settings.";
};


##################################
sub check_par {
  die "Unsupported operating system!\n" unless operating_system_is('OpenWrt');
  #say "OS version: ".operating_system_version();
  #say "OS release: ".operating_system_release();
  my $os_ver = operating_system_version();
  die "Unsupported firmware version!\n" if ($os_ver < 113 || $os_ver > 399);
  1;
}


sub uci {
  my $cmd = shift;
  my $output = run "uci $cmd", auto_die=>1, timeout=>10;
  say $output if $output;
};

sub quci {
  my $cmd = shift;
  my $output = run "uci -q $cmd", timeout=>10;
  say $output if $output;
};


sub insert_autogen_comment {
  my $file = shift;
  my $autogen_comment = '# This file is autogenerated. All changes will be overwritten!';
  my $output = run "sed -i \'1i $autogen_comment\' $file", timeout=>10;
  say $output if $output;
}


sub is_x86 {
  # check kernel architecture
  my %i = get_system_information;
  return ($i{architecture} =~ /i\d86/);
};


desc "OWRT routers: Show router information";
task "show_router", sub {
  #dump_system_information;
  my %i = get_system_information;
  #say Dumper \%info;
  say "This is: $i{hostname}, $i{operating_system} system (arch: $i{architecture}), version: $i{operating_system_release}.";
  if (operating_system_is('OpenWrt')) {
    my $r = run "uci get system.\@system[0].hostname";
    say "Hostname configured as: $r, actual: $i{hostname}.";
  }
  my $r = run "uptime";
  say "Host up time is: $r.";
  say "Memory total/free/used: $i{memory_total}/$i{memory_free}/$i{memory_used}.";
  say "Network interfaces:";
  my $net_info = $i{Network}->{networkconfiguration};
  for my $dev (keys %$net_info) {
    say " $dev ip: ".$net_info->{$dev}->{ip}." netmask: ".$net_info->{$dev}->{netmask};
  }
};


#
### Configuration
#
desc "OWRT routers: DEPLOY ROUTER
  rex -H 10.0.1.1 deploy_router --confhost=gwtest1";
task "deploy_router", sub {
  my $ch = shift->{confhost};
  my $p = read_db($ch);
  check_par;

  say 'Router deployment/OpenWRT/ started for '.$p->get_host;
  say "Router manufacturer from database: $p->{manufacturer}" if $p->{manufacturer};
  say "Router type from database: $p->{eq_name}" if $p->{eq_name};
  say "Department: $p->{dept_name}\n" if $p->{dept_name};
  # confhost parameter is required
  Deploy::Owrt::conf_system( { confhost => $ch } );
  sleep 1;
  Deploy::Owrt::conf_net( { confhost => $ch } );
  sleep 1;
  Deploy::Owrt::conf_fw( { confhost => $ch } );
  sleep 1;
  Deploy::Owrt::conf_tun( { confhost => $ch } );
  say 'Router deployment/OpenWRT/ finished for '.$p->get_host;
  say "!!! Reboot router manually to apply changes !!!";
};



desc "OWRT routers: Configure system parameters";
# --confhost=host parameter is required
task "conf_system", sub {
  my $ch = shift->{confhost};
  my $p = read_db($ch);
  check_par;

  say 'System configuration started for '.$p->get_host;

  my $tpl_sys_file = is_x86() ? 'files/system.x86.tpl' : 'files/system.tp1043.tpl';
  file "/etc/config/system",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template($tpl_sys_file),
    on_change => sub { say "/etc/config/system created." };

  file "/etc/banner",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template("files/banner.0.tpl", _hostname=>$p->get_host),
    on_change => sub { say "banner updated." };

  uci "revert system";

  # system parameters
  uci "set system.\@system[0].hostname=\'$p->{host}\'";
  uci "set system.\@system[0].timezone=\'UTC-5\'";
  if (defined $p->{log_ip} && $p->{log_ip} ne '') {
    uci "set system.\@system[0].log_ip=\'$p->{log_ip}\'";
    uci "set system.\@system[0].log_port=\'514\'";
  }
  say "/etc/config/system configured.";

  # ntp
  uci "set system.ntp.enable_server=0";
  if (defined $p->{ntp_ip} && $p->{ntp_ip} ne '') {
    uci "set system.ntp.enabled=1";
    uci "delete system.ntp.server";
    uci "add_list system.ntp.server=\'$p->{ntp_ip}\'";
  } else {
    uci "set system.ntp.enabled=0";
  }
  say "NTP server configured.";

  #uci "show system";
  uci "commit system";
  insert_autogen_comment '/etc/config/system';

  # tune sysctl
  file "/etc/sysctl.conf",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template('files/sysctl.conf.0.tpl'),
    on_change => sub { say "sysctl parameters configured." };

  say 'System configuration finished for '.$p->get_host;
};


desc "OWRT routers: Configure network";
# --confhost=host parameter is required
task "conf_net", sub {
  my $ch = shift->{confhost};
  my $p = read_db($ch);
  check_par;

  say 'Network configuration started for '.$p->get_host;

  my $tpl_net_file;
  my $lan_ifname;
  my $wan_ifname;
  if (is_x86()) {
    $tpl_net_file = 'files/network.x86.tpl';
    $lan_ifname = 'eth0';
    $wan_ifname = 'eth1';
  } else {
    $tpl_net_file = 'files/network.tp1043.tpl';
    $lan_ifname = 'eth1';
    $wan_ifname = 'eth0';
  }
  file "/etc/config/network",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template($tpl_net_file);
  uci "revert network";

  # create new ula on first re-boot
  file "/etc/uci-defaults/12_network-generate-ula",
    source => "files/12_network-generate-ula";

  uci "set network.lan.ifname=\'$lan_ifname\'";
  uci "set network.lan.proto=\'static\'";
  uci "set network.lan.ipaddr=\'$p->{lan_ip}\'";
  uci "set network.lan.netmask=\'$p->{lan_netmask}\'";
  uci "set network.lan.ipv6=0";

  uci "set network.wan.ifname=\'$wan_ifname\'";
  uci "set network.wan.proto=\'static\'";
  uci "set network.wan.ipaddr=\'$p->{wan_ip}\'";
  uci "set network.wan.netmask=\'$p->{wan_netmask}\'";
  uci "set network.wan.gateway=\'$p->{gateway}\'";
  uci "set network.wan.ipv6=0";

  quci "delete network.wan6";

  # lan routes
  foreach (@{$p->{lan_routes}}) {
    my $t = $_->{'type'};
    my $n = $_->{'name'};
    if ($t == 1) { # 1 UNICAST
      uci "set network.$n=route";
      uci "set network.$n.interface=lan";
      uci "set network.$n.target=\'$_->{target}\'";
      uci "set network.$n.netmask=\'$_->{netmask}\'";
      uci "set network.$n.gateway=\'$_->{gateway}\'";
      #uci "set network.$n.table=$_->{table}" if $_->{table};
    } else {
      die "Unsupported route type: $t";
    }
  }

  # auto wan routes
  foreach (@{$p->{auto_wan_routes}}) {
    my $n = $_->{'name'};
    uci "set network.$n=route";
    uci "set network.$n.interface=wan";
    uci "set network.$n.target=\'$_->{target}\'";
    uci "set network.$n.netmask=\'$_->{netmask}\'";
    uci "set network.$n.gateway=\'$_->{gateway}\'";
  }
  say "Network routes configured.";

  # dns
  quci "delete network.lan.dns";
  foreach (@{$p->{dns}}) {
    uci "add_list network.lan.dns=\'$_\'";
  }
  quci "delete network.lan.dns_search";
  #uci "add_list network.lan.dns_search=\'$p->{dhcp_dns_suffix}\'";
  say "/etc/config/network created and configured.";

  # dhcp
  file "/etc/config/dhcp",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template("files/dhcp.0.tpl");
  uci "revert dhcp";

  uci "set dhcp.\@dnsmasq[0].domainneeded=0";
  uci "set dhcp.\@dnsmasq[0].boguspriv=0";
  uci "set dhcp.\@dnsmasq[0].rebind_protection=0";
  uci "set dhcp.\@dnsmasq[0].domain=\'$p->{dns_suffix}\'";
  quci "delete dhcp.\@dnsmasq[0].local";
  uci "set dhcp.\@dnsmasq[0].logqueries=0";

  uci "set dhcp.lan.start=\'$p->{dhcp_start}\'";
  uci "set dhcp.lan.limit=\'$p->{dhcp_limit}\'";
  uci "set dhcp.lan.leasetime=\'$p->{dhcp_leasetime}\'";
  # disable dhcp at all
  uci "set dhcp.lan.ignore=".(($p->{dhcp_on} > 0)?0:1);
  # only allow static leases
  #uci "set dhcp.lan.dynamicdhcp=0";
  # dhcpv6
  uci "set dhcp.lan.dhcpv6=\'disabled\'";
  uci "set dhcp.lan.ra=\'disabled\'";

  quci "delete dhcp.lan.dhcp_option";
  #uci "add_list dhcp.lan.dhcp_option=\'3,192.168.33.81\'"; #router
  uci "add_list dhcp.lan.dhcp_option=\'6,$p->{dhcp_dns}\'" if $p->{dhcp_dns}; #dns
  uci "add_list dhcp.lan.dhcp_option=\'15,$p->{dhcp_dns_suffix}\'";
  uci "add_list dhcp.lan.dhcp_option=\'44,$p->{dhcp_wins}\'"; #wins
  uci "add_list dhcp.lan.dhcp_option=\'46,8\'";

  quci "delete dhcp.\@host[-1]" foreach 0..9;
  # static leases
  for (@{$p->{dhcp_static_leases}}) {
    uci "add dhcp host";
    uci "set dhcp.\@host[-1].ip=\'$_->{ip}\'";
    uci "set dhcp.\@host[-1].mac=\'$_->{mac}\'";
    uci "set dhcp.\@host[-1].name=\'$_->{name}\'";
  }
  say "DHCP and DNS configured.";

  #uci "show network";
  #uci "show dhcp";
  uci "commit network";
  uci "commit dhcp";
  insert_autogen_comment '/etc/config/network';
  insert_autogen_comment '/etc/config/dhcp';

  say "\nNetwork configuration finished for $p->{host}. Restarting the router will change the IP-s and enable DHCP server on LAN!!!.\n";
};


desc "OWRT routers: Configure firewall";
# --confhost=host parameter is required
task "conf_fw", sub {
  my $ch = shift->{confhost};
  my $p = read_db($ch);
  check_par;

  say 'Firewall configuration started for '.$p->get_host;

  pkg "firewall", ensure => "present";

  file "/etc/config/firewall",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template("files/firewall.0.tpl");

  uci "revert firewall";
  foreach (@{$p->{ssh_icmp_from_wans_ips}}) {
    # icmp-wan-in-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'icmp-wan-in-$_\'";
    uci "set firewall.\@rule[-1].src=wan";
    uci "set firewall.\@rule[-1].proto=icmp";
    uci "set firewall.\@rule[-1].src_ip=\'$_\'";
    uci "set firewall.\@rule[-1].target=ACCEPT";
    # ssh-wan-in-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'ssh-wan-in-$_\'";
    uci "set firewall.\@rule[-1].src=wan";
    uci "set firewall.\@rule[-1].proto=tcp";
    uci "set firewall.\@rule[-1].src_ip=\'$_\'";
    uci "set firewall.\@rule[-1].dest_port=22";
    uci "set firewall.\@rule[-1].target=ACCEPT";
    # ssh-wan-out-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'ssh-wan-out-$_\'";
    uci "set firewall.\@rule[-1].dest=wan";
    uci "set firewall.\@rule[-1].proto=tcp";
    uci "set firewall.\@rule[-1].dest_ip=\'$_\'";
    uci "set firewall.\@rule[-1].src_port=22";
    uci "set firewall.\@rule[-1].target=ACCEPT";
  }

  # icmp-wan-in-limit
  uci "add firewall rule";
  #uci "set firewall.\@rule[-1].name=icmp-wan-in-limit";
  uci "set firewall.\@rule[-1].src=wan";
  uci "set firewall.\@rule[-1].proto=icmp";
  uci "add_list firewall.\@rule[-1].icmp_type=$_" foreach (0,3,4,8,11,12);
  uci "set firewall.\@rule[-1].limit=\'20/sec\'";
  uci "set firewall.\@rule[-1].target=ACCEPT";

  # icmp-wan-out
  uci "add firewall rule";
  #uci "set firewall.\@rule[-1].name=icmp-wan-out";
  uci "set firewall.\@rule[-1].dest=wan";
  uci "set firewall.\@rule[-1].proto=icmp";
  uci "set firewall.\@rule[-1].target=ACCEPT";

  # syslog-wan-out
  uci "add firewall rule";
  #uci "set firewall.\@rule[-1].name=syslog-wan-out";
  uci "set firewall.\@rule[-1].dest=wan";
  uci "set firewall.\@rule[-1].proto=udp";
  uci "set firewall.\@rule[-1].dest_ip=\'$p->{log_ip}\'";
  uci "set firewall.\@rule[-1].dest_port=514";
  uci "set firewall.\@rule[-1].target=ACCEPT";

  #####
  my @outgoing_rules_ip_list;
  recursive_search_by_from_hostname(\@outgoing_rules_ip_list, $p->{tun_node_name},
    $p->{tun_array_ref}, $p->{tun_node_name});
  #say 'Outgoing: ', Dumper \@outgoing_rules_ip_list;

  my @incoming_rules_ip_list;
  recursive_search_by_to_hostname(\@incoming_rules_ip_list, $p->{tun_node_name},
    $p->{tun_array_ref}, $p->{tun_node_name});
  #say 'Incoming: ', Dumper \@incoming_rules_ip_list;

  # build outgoing tinc rules
  foreach (@outgoing_rules_ip_list) {
    # tinc-outgoing-wan-in-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'tinc-outgoing-wan-in-$_\'";
    uci "set firewall.\@rule[-1].src=wan";
    uci "set firewall.\@rule[-1].proto=tcpudp";
    uci "set firewall.\@rule[-1].src_ip=\'$_\'";
    uci "set firewall.\@rule[-1].src_port=655";
    uci "set firewall.\@rule[-1].family=ipv4";
    uci "set firewall.\@rule[-1].target=ACCEPT";
    # tinc-outgoing-wan-out-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'tinc-outgoing-wan-out-$_\'";
    uci "set firewall.\@rule[-1].dest=wan";
    uci "set firewall.\@rule[-1].proto=tcpudp";
    uci "set firewall.\@rule[-1].dest_ip=\'$_\'";
    uci "set firewall.\@rule[-1].dest_port=655";
    uci "set firewall.\@rule[-1].family=ipv4";
    uci "set firewall.\@rule[-1].target=ACCEPT";
  }
  # build incoming tinc rules
  foreach (@incoming_rules_ip_list) {
    # tinc-incoming-wan-in-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'tinc-incoming-wan-in-$_\'";
    uci "set firewall.\@rule[-1].src=wan";
    uci "set firewall.\@rule[-1].proto=tcpudp";
    uci "set firewall.\@rule[-1].src_ip=\'$_\'";
    uci "set firewall.\@rule[-1].dest_port=655";
    uci "set firewall.\@rule[-1].family=ipv4";
    uci "set firewall.\@rule[-1].target=ACCEPT";
    # tinc-incoming-wan-out-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'tinc-incoming-wan-out-$_\'";
    uci "set firewall.\@rule[-1].dest=wan";
    uci "set firewall.\@rule[-1].proto=tcpudp";
    uci "set firewall.\@rule[-1].dest_ip=\'$_\'";
    uci "set firewall.\@rule[-1].src_port=655";
    uci "set firewall.\@rule[-1].family=ipv4";
    uci "set firewall.\@rule[-1].target=ACCEPT";
  }

  uci "add firewall include";
  uci "set firewall.\@include[-1].path=\'/etc/firewall.user\'";

  #uci "show firewall";
  uci "commit firewall";
  insert_autogen_comment '/etc/config/firewall';

  file "/etc/firewall.user",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template("files/firewall.user.0.tpl");

  say 'Firewall configuration finished for '.$p->get_host;
};


desc "OWRT routers: Configure tinc tunnel";
# --confhost=host parameter is required
task "conf_tun", sub {
  my $ch = shift->{confhost};
  my $p = read_db($ch);
  check_par;

  say 'Tinc tunnel configuration started for '.$p->get_host;

  pkg "tinc", ensure => "present";

  file "/etc/config/tinc",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template("files/tinc.0.tpl");
  quci "revert tinc";

  uci "set tinc.$def_net=tinc-net";
  uci "set tinc.\@tinc-net[-1].enabled=1";
  uci "set tinc.\@tinc-net[-1].debug=2";
  uci "set tinc.\@tinc-net[-1].AddressFamily=ipv4";
  uci "set tinc.\@tinc-net[-1].Interface=vpn1";
  uci "set tinc.\@tinc-net[-1].MaxTimeout=600";
  uci "set tinc.\@tinc-net[-1].Name=\'$p->{tun_node_name}\'";
  uci "add_list tinc.\@tinc-net[-1].ConnectTo=\'$_\'" foreach (@{$p->{tun_connect_nodes}});

  uci "set tinc.$p->{tun_node_name}=tinc-host";
  uci "set tinc.\@tinc-host[-1].enabled=1";
  uci "set tinc.\@tinc-host[-1].net=\'$def_net\'";
  uci "set tinc.\@tinc-host[-1].Cipher=blowfish";
  uci "set tinc.\@tinc-host[-1].Compression=0";
  uci "add_list tinc.\@tinc-host[-1].Address=\'$p->{tun_node_ip}\'";
  uci "set tinc.\@tinc-host[-1].Subnet=\'$p->{tun_subnet}\'";

  #uci "show tinc";
  uci "commit tinc";
  insert_autogen_comment '/etc/config/tinc';
  say "File /etc/config/tinc configured.";

  # configure tinc scripts
  file "/etc/tinc/$def_net",
    owner => "ural",
    group => "root",
    mode => 755,
    ensure => "directory";

  file "/etc/tinc/$def_net/tinc-up",
    owner => "ural",
    group => "root",
    mode => 755,
    content => template("files/tinc/$def_net/tinc-up.tpl",
      _tun_ip =>$p->{tun_int_ip},
      _tun_netmask=>$p->{tun_int_netmask});
  
  file "/etc/tinc/$def_net/tinc-down",
    owner => "ural",
    group => "root",
    mode => 755,
    content => template("files/tinc/$def_net/tinc-down.tpl");
  say "Scripts tinc-up/tinc-down are created.";

  unless ($p->{tun_pub_key} && $p->{tun_priv_key}) {
    say "No keypair found in the database, running gen_node for $p->{tun_node_name}...";
    run_task "Deploy:Owrt:gen_node", params=>{newnode=>$p->{tun_node_name}};
  } else {
    say "Keypair for $p->{tun_node_name} from the database is used.";
  }
    
  # configure tinc keys
  file "/etc/tinc/$def_net/rsa_key.priv",
    owner => "ural",
    group => "root",
    mode => 600,
    content => $p->{tun_priv_key};
  say "Tinc private key file for $p->{tun_node_name} is saved to rsa_key.priv";

  # generate all hosts files for this node
  sleep 1;
  Deploy::Owrt::dist_nodes( { confhost => $ch } );

  say 'Tinc tunnel configuration finished for '.$p->get_host;
};


##################################
desc "Tinc net generate keys for node (run on *bikini* host only please)
  rex gen_node --newnode=gwtest1";
task "gen_node", sub {
  my $par = shift;
  my $_host = $par->{newnode};
  my $keysize = 2048;

  my %i = get_system_information;
  #say "Host: $i{hostname}";
  die "This task can be run only on bikini host.\n" unless $i{hostname} eq 'bikini';
  die "Invalid parameters, run as: rex gen_node --newnode=hostname.\n" unless $_host;

  # prepare database
  my $dbh = DBI->connect("DBI:mysql:database=".get(cmdb('dbname')).';host='.get(cmdb('dbhost')), get(cmdb('dbuser')), get(cmdb('dbpass'))) or 
    die "Connection to the database failed.\n";
  $dbh->do("SET NAMES 'UTF8'");

  my ($r_id) = $dbh->selectrow_array("SELECT id FROM routers WHERE host_name = ?", {}, $_host);
  die "There's no such host in the database, or database error.\n" unless $r_id;
  #say $r_id;

  say "Generating keys for node: $_host";
  #unless (is_installed("openssl")) {
  #  say "Openssl is required.";
  #  return 1;
  #}
  my $privkey = run "openssl genrsa $keysize", auto_die=>1;
  #say $privkey;
  say "Private key generated.";
  my $pubkey = run "openssl rsa -pubout -outform PEM << EOF123EOF\n$privkey\nEOF123EOF\n", auto_die=>1;
  #say $pubkey;
  say "Public key generated.";

  # save keys to database
  my $rows = $dbh->do("UPDATE vpns SET pub_key=?, priv_key=? WHERE router_id = ?", {}, $pubkey, $privkey, $r_id);
  die "Can't save keys to database.\n".$dbh->errstr."\n" unless $rows;

  $dbh->disconnect;
  say "Keys were successfully written to database.";
};


desc "Distribute tinc net hosts files to host (works on erebus too)";
# --confhost=host parameter is required
task "dist_nodes", sub {
  my $params = shift;
  my $ch = $params->{confhost};
  my $p = read_db($ch, skip_erebus_check=>1);

  say 'Tinc hostfiles distribution started for '.$p->get_host;

  file "/etc/tinc/$def_net/hosts",
    owner => "ural",
    group => "root",
    mode => 755,
    ensure => "directory";

  # build host files for all nodes in database
  my $dbh = DBI->connect("DBI:mysql:database=".get(cmdb('dbname')).';host='.get(cmdb('dbhost')), get(cmdb('dbuser')), get(cmdb('dbpass'))) or 
    die "Connection to the database failed.\n";
  $dbh->do("SET NAMES 'UTF8'");

  my $s = $dbh->prepare("SELECT \
routers.host_name AS tun_node_name, \
ifs.ip AS tun_node_ip, \
nets.net_ip AS tun_subnet_ip, \
nets.mask AS tun_subnet_mask, \
pub_key AS tun_pub_key \
FROM vpns \
INNER JOIN routers ON routers.id = router_id \
INNER JOIN nets ON nets.id = subnet_id \
INNER JOIN interfaces ifs ON ifs.id = node_if_id") or die $dbh->errstr;
  $s->execute or die $s->errstr;
  my @hosts_files;
  while (my $hr = $s->fetchrow_hashref) {
    #say Dumper $hr;

    unless ($hr->{tun_pub_key} && $hr->{tun_subnet_ip} && $hr->{tun_subnet_mask} && $hr->{tun_node_ip}) {
      say "Host file for node $hr->{tun_node_name} is not generated due incorrect configuration:";
      say "- No public key in database. Generate keys for this host and run distribution again." unless ($hr->{tun_pub_key});
      say "- No vpn subnet ip/mask in database. Check configuration." unless ($hr->{tun_subnet_ip} && $hr->{tun_subnet_mask});
      say "- No vpn ip in database. Check configuration." unless ($hr->{tun_node_ip});
      next;
    }

    my $net = NetAddr::IP::Lite->new($hr->{tun_subnet_ip}, $hr->{tun_subnet_mask}) or
      die("Invalid vpn subnet address or mask!\n");

    # now generate tinc host file with public key
    file "/etc/tinc/$def_net/hosts/$hr->{tun_node_name}",
      owner => "ural",
      group => "root",
      mode => 644,
      content => template("files/tinc/$def_net/hostfile.tpl",
	_address=>$hr->{tun_node_ip},
	_subnet=>$net->cidr,
        _pubkey=>$hr->{tun_pub_key});
    push @hosts_files, $hr->{tun_node_name};
    say "Host file for $hr->{tun_node_name} is generated.";
  }
  $dbh->disconnect;

  # check for hosts in connection list exist
  my @_con_list = @{$p->{tun_connect_nodes}};
  push @_con_list, $p->{tun_node_name}; # current host must be in list too
  foreach my $h (@_con_list) {
    my $f = 0;
    foreach (@hosts_files) {
      if ($h eq $_) { $f = 1; last; }
    }
    say "WARNING! Host $h is in tinc connection list, but not distributed." unless ($f);
  }

  say 'Tinc hostfiles distribution finished for '.$p->get_host;
};


desc "Reload tinc daemon (useful after updating net hosts files, works on erebus too)";
task "reload_tinc", sub {
  my $pf = "/var/run/tinc.$def_net.pid";
  if (is_readable($pf)) {
    say "Reloading tinc daemon on host ".connection->server." ...";
    run "kill -HUP `cat $pf`";
    say "HUP signal is sent.";
  } else {
    say "Pid file $pf wasn't found. May be wrong host, or tinc is not running.";
  }
};


##################################
task "_t", sub {
  my $p = read_db 'gwsouth2';
  #my $p = read_db 'gwtest1';
  check_par;
  $p->dump;

  #my @outgoing_rules_ip_list;
  #recursive_search_by_from_hostname(\@outgoing_rules_ip_list, $p->{tun_node_name},
  #  $p->{tun_array_ref}, $p->{tun_node_name});
  #say 'Outgoing: ', Dumper \@outgoing_rules_ip_list;

  #my @incoming_rules_ip_list;
  #recursive_search_by_to_hostname(\@incoming_rules_ip_list, $p->{tun_node_name},
  #  $p->{tun_array_ref}, $p->{tun_node_name});
  #say 'Incoming: ', Dumper \@incoming_rules_ip_list;

  #check_par;
  #$p->dump;
}, {dont_register => TRUE};

1;

=pod

=head1 NAME

$::module_name - {{ SHORT DESCRIPTION }}

=head1 DESCRIPTION

{{ LONG DESCRIPTION }}

=head1 USAGE

{{ USAGE DESCRIPTION }}

 include qw/Deploy::Owrt/;

 task yourtask => sub {
    Deploy::Owrt::example();
 };

=head1 TASKS

=over 4

=item example

This is an example Task. This task just output's the uptime of the system.

=back

=cut
