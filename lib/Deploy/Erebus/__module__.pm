package Deploy::Erebus;

use Rex -feature=>['1.4'];
use Rex::Commands::Cron;
use Data::Dumper;
use File::Basename;
use NetAddr::IP::Lite;
use feature 'state';

use Ural::Deploy::ReadDB_Erebus qw(read_db);

my $def_net = 'UWC66';

### Helpers
sub recursive_search_by_from_hostname {
  my ($listref, $hostname, $tun_array_ref, $tun_node_name) = @_;

  state $loop_control = 0;
  die "Wrong tunnels configuration (reqursive infinite loop found).\n" if $loop_control++ >= 30;

  my @tt1 = grep { $_->{from_hostname} eq $hostname } @$tun_array_ref;
  foreach my $hh1 (@tt1) {
    unless ((grep { $_ eq $hh1->{to_ip} } @$listref) || ($hh1->{to_hostname} eq $tun_node_name)) {
      push @$listref, $hh1->{to_ip};
      recursive_search_by_from_hostname($listref, $hh1->{to_hostname}, $tun_array_ref, $tun_node_name);
    }
  }
}


sub recursive_search_by_to_hostname {
  my ($listref, $hostname, $tun_array_ref, $tun_node_name) = @_;

  state $loop_control = 0;
  die "Wrong tunnels configuration (reqursive infinite loop found).\n" if $loop_control++ >= 30;

  my @tt1 = grep { $_->{to_hostname} eq $hostname } @$tun_array_ref;
  foreach my $hh1 (@tt1) {
    unless ((grep { $_ eq $hh1->{from_ip} } @$listref) || ($hh1->{from_hostname} eq $tun_node_name)) {
      push @$listref, $hh1->{from_ip};
      recursive_search_by_to_hostname($listref, $hh1->{from_hostname}, $tun_array_ref, $tun_node_name);
    }
  }
}


sub check_par {
  die "Unsupported operating system!\n" unless operating_system_is('OpenWrt');
  #say "OS version: ".operating_system_version();
  #say "OS release: ".operating_system_release();
  my $os_ver = operating_system_version();
  die "Unsupported firmware version!\n" if ($os_ver < 114 || $os_ver > 399);
  1;
}


sub uci {
  my $cmd = shift;
  my $output = run "uci $cmd", auto_die=>1, timeout=>10;
  say $output if $output;
};

sub quci {
  my $cmd = shift;
  my $output = run "uci -q $cmd", timeout=>10;
  say $output if $output;
};


sub insert_autogen_comment {
  my $file = shift;
  my $autogen_comment = '# This file is autogenerated. All changes will be overwritten!';
  my $output = run "sed -i \'1i $autogen_comment\' $file", timeout=>10;
  say $output if $output;
}


#
### Configuration
#
desc "Erebus router: DEPLOY ROUTER
  rex -H 10.0.1.1 Deploy:Erebus:deploy_router [--confhost=erebus]";
task "deploy_router", sub {
  my $ch = shift->{confhost} || 'erebus';
  my $p = read_db($ch);
  check_par;

  say 'Router deployment/Erebus/ started for '.$p->get_host;
  say "Router manufacturer from database: $p->{manufacturer}" if $p->{manufacturer};
  say "Router type from database: $p->{eq_name}" if $p->{eq_name};
  say "Department: $p->{dept_name}\n" if $p->{dept_name};
  Deploy::Erebus::conf_software();
  sleep 1;
  Deploy::Erebus::conf_system();
  sleep 1;
  Deploy::Erebus::conf_net();
  sleep 1;
  Deploy::Erebus::conf_fw();
  sleep 1;
  Deploy::Erebus::conf_ipsec();
  sleep 1;
  Deploy::Erebus::conf_tinc();
  sleep 1;
  Deploy::Erebus::conf_r2d2();
  sleep 1;
  Deploy::Erebus::conf_snmp();
  say 'Router deployment/Erebus/ finished for '.$p->get_host;
  say "!!! Reboot router manually to apply changes !!!";
};


desc "Erebus router: Configure software";
# --confhost=erebus or empty is allowed
task "conf_software", sub {
  my $ch = shift->{confhost} || 'erebus';
  my $p = read_db($ch);
  check_par;

  say 'Software configuration started for '.$p->get_host;

  # disable failsafe mode prompt (erebus is always x64)
  say "Disabling failsafe mode prompts.";
  file "/lib/preinit/30_failsafe_wait", ensure=>'absent';
  file "/lib/preinit/99_10_failsafe_login", ensure=>'absent';

  # install packages
  say "Updating package database.";
  update_package_db;
  say "Installing / updating packages.";
  for (qw/ip-full tc conntrack kmod-sched
    iperf3 irqbalance ethtool lm-sensors lm-sensors-detect
    strongswan-default tinc snmpd snmp-utils
    perl perlbase-encode perlbase-findbin perl-dbi perl-dbd-mysql perl-netaddr-ip perl-sys-runalone
    libmariadb openssh-client/) {
    pkg $_, ensure => latest,
      on_change => sub { say "package $_ was installed." };
  }
  say 'Software configuration finished for '.$p->get_host;
};


desc "Erebus router: Configure system parameters";
# --confhost=erebus or empty is allowed
task "conf_system", sub {
  my $ch = shift->{confhost} || 'erebus';
  my $p = read_db($ch);
  check_par;

  say 'System configuration started for '.$p->get_host;

  my $tpl_sys_file = 'files/system.x86.tpl';
  file "/etc/config/system",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template($tpl_sys_file),
    on_change => sub { say "/etc/config/system created." };

  file "/etc/banner",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template("files/banner.0.tpl", _hostname=>$p->get_host),
    on_change => sub { say "banner updated." };

  uci "revert system";

  # system parameters
  uci "set system.\@system[0].hostname=\'$p->{host}\'";
  uci "set system.\@system[0].timezone=\'UTC-5\'";
  uci "set system.\@system[0].ttylogin=\'1\'";
  if (defined $p->{log_ip} && $p->{log_ip} ne '') {
    uci "set system.\@system[0].log_ip=\'$p->{log_ip}\'";
    uci "set system.\@system[0].log_port=\'514\'";
  }
  say "/etc/config/system configured.";

  # ntp
  uci "set system.ntp.enable_server=0";
  if (defined $p->{ntp_ip} && $p->{ntp_ip} ne '') {
    uci "set system.ntp.enabled=1";
    uci "delete system.ntp.server";
    uci "add_list system.ntp.server=\'$p->{ntp_ip}\'";
  } else {
    uci "set system.ntp.enabled=0";
  }
  say "NTP server configured.";

  #uci "show system";
  uci "commit system";
  insert_autogen_comment '/etc/config/system';

  # tune sysctl
  file "/etc/sysctl.conf",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template('files/sysctl.conf.0.tpl'),
    on_change => sub { say "sysctl parameters configured." };

  say 'System configuration finished for '.$p->get_host;
};


desc "Erebus router: Configure network";
# --confhost=erebus or empty is allowed
task "conf_net", sub {
  my $ch = shift->{confhost} || 'erebus';
  my $p = read_db($ch);
  check_par;

  say 'Network configuration started for '.$p->get_host;

  my $network_file = '/etc/config/network';
  file $network_file,
    owner => "ural",
    group => "root",
    mode => 644,
    content => template('files/network.x86.tpl');
  uci "revert network";

  # create new ula on first re-boot
  file "/etc/uci-defaults/12_network-generate-ula",
    source => "files/12_network-generate-ula";

  quci "delete network.lan";
  quci "delete network.wan";
  quci "delete network.wan6";

  my $lan_ifname = 'eth0';
  my $wan_ifname = 'eth1';

  # lan
  my $gw = ($p->{gateway}) ? NetAddr::IP::Lite->new($p->{gateway}) : undef;
  my $ifs_r = $p->{lan_ifs};
  for (sort keys %$ifs_r) {
    my $if_r = $ifs_r->{$_};
    my $part_vlan = ($if_r->{vlan}) ? ".$if_r->{vlan}" : '';
    uci "set network.$_=interface";
    uci "set network.$_.ifname=\'$lan_ifname$part_vlan\'";
    uci "set network.$_.proto=\'static\'";
    uci "set network.$_.ipaddr=\'$if_r->{ip}\'";
    uci "set network.$_.netmask=\'$if_r->{netmask}\'";
    my $net = NetAddr::IP::Lite->new($if_r->{ip}, $if_r->{netmask});
    uci "set network.$_.gateway=\'$p->{gateway}\'" if ($gw && $net && $gw->within($net));
    uci "set network.$_.ipv6=0";
  }
  # wan
  $ifs_r = $p->{wan_ifs};
  for (sort keys %$ifs_r) {
    my $if_r = $ifs_r->{$_};
    my $part_vlan = ($if_r->{vlan}) ? ".$if_r->{vlan}" : '';
    uci "set network.$_=interface";
    uci "set network.$_.ifname=\'$wan_ifname$part_vlan\'";
    uci "set network.$_.proto=\'static\'";
    uci "set network.$_.ipaddr=\'$if_r->{ip}\'";
    uci "set network.$_.netmask=\'$if_r->{netmask}\'";
    my $net = NetAddr::IP::Lite->new($if_r->{ip}, $if_r->{netmask});
    uci "set network.$_.gateway=\'$p->{gateway}\'" if ($gw && $net && $gw->within($net));
    uci "set network.$_.ipv6=0";
  }
  #uci "set network.lan.ipaddr=\'10.0.1.1\'"; #FIXME
  #uci "set network.lan.netmask=\'255.192.0.0\'"; #FIXME

  # rt_tables
  my $rt_file = '/etc/iproute2/rt_tables';
  file $rt_file,
    owner => "ural",
    group => "root",
    mode => 644,
    source => "files/rt_tables",
    on_change => sub { say "/etc/iproute2/rt_tables created." };

  my $h = $p->{hacks}{rt_tables_config};
  append_if_no_such_line($rt_file,
    line => $h,
    on_change => sub {
      say "Hack rt_tables_config was added to rt_tables.";
    }
  ) if $h;

  # routes
  for my $ifs_r ($p->{lan_ifs}, $p->{wan_ifs}) {
    for (sort keys %$ifs_r) {
      my $r_interface = $_;
      my $r = $ifs_r->{$_}{routes};
      if ($r) {
	for (@$r) {
	  my $t = $_->{type};
	  my $n = $_->{name};
	  if ($t == 1 || $t == 9) { # 1 UNICAST / 9 surrogate IPSEC
	    uci "set network.$n=route";
	    uci "set network.$n.interface=$r_interface";
	    uci "set network.$n.target=$_->{target}";
	    uci "set network.$n.netmask=$_->{netmask}";
	    uci "set network.$n.gateway=$_->{gateway}";
	    uci "set network.$n.table=$_->{table}" if $_->{table};
	  } else {
	    die "Unsupported route type: $t";
	  }
	}
      }
    }
  }

  say "/etc/config/network created and configured.";

  # dhcp
  file "/etc/config/dhcp",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template("files/dhcp.0.tpl");
  uci "revert dhcp";

  uci "set dhcp.\@dnsmasq[0].domainneeded=0";
  uci "set dhcp.\@dnsmasq[0].boguspriv=0";
  uci "set dhcp.\@dnsmasq[0].rebind_protection=0";
  # dns
  uci "set dhcp.\@dnsmasq[0].domain=\'$p->{dns_suffix}\'";
  quci "delete dhcp.\@dnsmasq[0].local";
  quci "delete dhcp.\@dnsmasq[0].server";
  foreach (@{$p->{dns}}) {
    uci "add_list dhcp.\@dnsmasq[0].server=\'$_\'";
  }

  uci "set dhcp.\@dnsmasq[0].logqueries=0";

  #quci "delete dhcp.\@dnsmasq[0].interface";
  #uci "add_list dhcp.\@dnsmasq[0].interface=\'lan\'"; # dnsmasq listen only lan

  # lan, wan is not used
  quci "delete dhcp.lan";
  quci "delete dhcp.wan";

  # dhcp configuration for interfaces
  for my $ifs_r ($p->{lan_ifs}, $p->{wan_ifs}) {
    for (sort keys %$ifs_r) {
      uci "set dhcp.$_=dhcp"; # $_ interface
      uci "set dhcp.$_.interface=\'$_\'";
      if ($ifs_r->{$_}{dhcp_on} > 0) {
	uci "set dhcp.$_.ignore=0";
	uci "set dhcp.$_.start=\'$ifs_r->{$_}{dhcp_start}\'";
	uci "set dhcp.$_.limit=\'$ifs_r->{$_}{dhcp_limit}\'";
	uci "set dhcp.$_.leasetime=\'$ifs_r->{$_}{dhcp_leasetime}\'";
	# only allow static leases
	#uci "set dhcp.$_.dynamicdhcp=0";
	# dhcpv6
	uci "set dhcp.$_.dhcpv6=\'disabled\'";
	uci "set dhcp.$_.ra=\'disabled\'";

	quci "delete dhcp.$_.dhcp_option";
	#uci "add_list dhcp.$_.dhcp_option=\'3,192.168.33.81\'"; #router
	uci "add_list dhcp.$_.dhcp_option=\'6,$ifs_r->{$_}{dhcp_dns}\'" if $ifs_r->{$_}{dhcp_dns}; #dns
	uci "add_list dhcp.$_.dhcp_option=\'15,$ifs_r->{$_}{dhcp_dns_suffix}\'";
	uci "add_list dhcp.$_.dhcp_option=\'44,$ifs_r->{$_}{dhcp_wins}\'"; #wins
	uci "add_list dhcp.$_.dhcp_option=\'46,8\'";
      } else {
        # disable dhcp at all
        uci "set dhcp.$_.ignore=1";
      }
    }
  }
  quci "delete dhcp.\@host[-1]" foreach 0..9;
  # static leases
  for my $ifs_r ($p->{lan_ifs}, $p->{wan_ifs}) {
    for (sort keys %$ifs_r) {
      if ($ifs_r->{$_}{dhcp_on} > 0) {
        for my $l (@{$ifs_r->{$_}{dhcp_static_leases}}) {
	  uci "add dhcp host";
	  uci "set dhcp.\@host[-1].ip=\'$l->{ip}\'";
	  uci "set dhcp.\@host[-1].mac=\'$l->{mac}\'";
	  uci "set dhcp.\@host[-1].name=\'$l->{name}\'";
        }
      }
    }
  }

  say "DHCP and DNS configured.";

  #uci "show network";
  #uci "show dhcp";
  uci "commit network";
  uci "commit dhcp";
  insert_autogen_comment $network_file;
  insert_autogen_comment '/etc/config/dhcp';

  # append ip_rules_config hack to network
  $h = $p->{hacks}{ip_rules_config};
  append_if_no_such_line($network_file,
    line => $h,
    on_change => sub {
      say "Hack ip_rules_config was added to /etc/config/network.";
    }
  ) if $h;

  say "\nNetwork configuration finished for $p->{host}. Restarting the router will change the IP-s!!!.\n";
};


desc "Erebus router: Configure IPsec";
# --confhost=erebus or empty is allowed
task "conf_ipsec", sub {
  my $ch = shift->{confhost} || 'erebus';
  my $p = read_db($ch);
  check_par;

  say 'IPsec configuration started for '.$p->get_host;

  pkg "strongswan-default", ensure => "present";

  # strongswan init
  file '/etc/init.d/ipsec',
    owner => "ural",
    group => "root",
    mode => 755,
    source => "files/ipsec.init",
    on_change => sub { say "Strongswan init file created." };
  
  # strongswan config
  my $ipsec_file = '/etc/config/ipsec';
  file $ipsec_file,
    owner => "ural",
    group => "root",
    mode => 644,
    content => template('files/ipsec.0.tpl'),
    on_change => sub { say "/etc/config/ipsec created." };

  my $h = $p->{hacks}{strongswan_config};
  append_if_no_such_line($ipsec_file,
    line => $h,
    on_change => sub {
      say "Hack strongswan_config was added to /etc/config/ipsec.";
    }
  ) if $h;

  say 'IPsec configuration finished for '.$p->get_host;
};


desc "Erebus router: Configure tinc";
# --confhost=erebus or empty is allowed
task "conf_tinc", sub {
  my $ch = shift->{confhost} || 'erebus';
  my $p = read_db($ch);
  check_par;

  say 'Tinc configuration started for '.$p->get_host;

  pkg "tinc", ensure => "present";

  file "/etc/config/tinc",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template("files/tinc.0.tpl");
  quci "revert tinc";

  uci "set tinc.$def_net=tinc-net";
  uci "set tinc.\@tinc-net[-1].enabled=1";
  uci "set tinc.\@tinc-net[-1].debug=2";
  uci "set tinc.\@tinc-net[-1].AddressFamily=ipv4";
  uci "set tinc.\@tinc-net[-1].Interface=vpn1";
  uci "set tinc.\@tinc-net[-1].BindToAddress=\'$p->{tun_node_ip}\'";
  uci "set tinc.\@tinc-net[-1].MaxTimeout=600";
  uci "set tinc.\@tinc-net[-1].Name=\'$p->{tun_node_name}\'";
  uci "add_list tinc.\@tinc-net[-1].ConnectTo=\'$_\'" for (@{$p->{tun_connect_nodes}});

  uci "set tinc.$p->{tun_node_name}=tinc-host";
  uci "set tinc.\@tinc-host[-1].enabled=1";
  uci "set tinc.\@tinc-host[-1].net=\'$def_net\'";
  uci "set tinc.\@tinc-host[-1].Cipher=blowfish";
  uci "set tinc.\@tinc-host[-1].Compression=0";
  uci "add_list tinc.\@tinc-host[-1].Address=\'$p->{tun_node_ip}\'";
  uci "set tinc.\@tinc-host[-1].Subnet=\'$p->{tun_subnet}\'";

  #uci "show tinc";
  uci "commit tinc";
  insert_autogen_comment '/etc/config/tinc';
  say "File /etc/config/tinc configured.";

  # configure tinc scripts
  file "/etc/tinc/$def_net",
    owner => "ural",
    group => "root",
    mode => 755,
    ensure => "directory";

  my $int_addr = NetAddr::IP::Lite->new($p->{tun_int_ip}, $p->{tun_int_netmask}) or
    die "Invalid vpn tunnel interface address or mask!\n";
  file "/etc/tinc/$def_net/tinc-up",
    owner => "ural",
    group => "root",
    mode => 755,
    content => template("files/tinc/$def_net/tinc-up.tpl",
      _tun_ip =>$int_addr->addr,
      _tun_netmask=>$int_addr->mask,
      _tun_route_addr=>$int_addr->network->cidr,
    );
  
  file "/etc/tinc/$def_net/tinc-down",
    owner => "ural",
    group => "root",
    mode => 755,
    content => template("files/tinc/$def_net/tinc-down.tpl",
      _tun_route_addr=>$int_addr->network->cidr,
    );
  say "Scripts tinc-up/tinc-down are created.";

  unless ($p->{tun_pub_key} && $p->{tun_priv_key}) {
    say "No keypair found in the database, running gen_node for $p->{tun_node_name}...";
    run_task "Deploy:Owrt:gen_node", params=>{newnode=>$p->{tun_node_name}};
  } else {
    say "Keypair for $p->{tun_node_name} from the database is used.";
  }
    
  # configure tinc keys
  file "/etc/tinc/$def_net/rsa_key.priv",
    owner => "ural",
    group => "root",
    mode => 600,
    content => $p->{tun_priv_key},
    on_change => sub {
      say "Tinc private key file for $p->{tun_node_name} is saved to rsa_key.priv";
    };

  # generate all hosts files for this (=erebus) node
  sleep 1;
  Deploy::Owrt::dist_nodes( { confhost => $ch } );

  say 'Tinc configuration finished for '.$p->get_host;
};


desc "Erebus router: Configure firewall";
# --confhost=erebus or empty is allowed
task "conf_fw", sub {
  my $ch = shift->{confhost} || 'erebus';
  my $p = read_db($ch);
  check_par;

  say 'Firewall configuration started for '.$p->get_host;

  pkg "firewall", ensure => "present";

  my @lan_ifs = sort keys %{$p->{lan_ifs}};
  my @wan_ifs = sort keys %{$p->{wan_ifs}};
  file "/etc/config/firewall",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template("files/firewall.0.tpl",
      _lan_interfaces => \@lan_ifs,
      _wan_interfaces => \@wan_ifs,
    );

  uci "revert firewall";

  foreach (@{$p->{ssh_icmp_from_wans_ips}}) {
    # icmp-wan-in-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'icmp-wan-in-$_\'";
    uci "set firewall.\@rule[-1].src=wan";
    uci "set firewall.\@rule[-1].proto=icmp";
    uci "set firewall.\@rule[-1].src_ip=\'$_\'";
    uci "set firewall.\@rule[-1].target=ACCEPT";
    # ssh-wan-in-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'ssh-wan-in-$_\'";
    uci "set firewall.\@rule[-1].src=wan";
    uci "set firewall.\@rule[-1].proto=tcp";
    uci "set firewall.\@rule[-1].src_ip=\'$_\'";
    uci "set firewall.\@rule[-1].dest_port=22";
    uci "set firewall.\@rule[-1].target=ACCEPT";
  }

  # icmp-wan-in-limit
  uci "add firewall rule";
  #uci "set firewall.\@rule[-1].name=icmp-wan-in-limit";
  uci "set firewall.\@rule[-1].src=wan";
  uci "set firewall.\@rule[-1].proto=icmp";
  uci "add_list firewall.\@rule[-1].icmp_type=$_" foreach (0,3,4,8,11,12);
  uci "set firewall.\@rule[-1].limit=\'10/sec\'";
  uci "set firewall.\@rule[-1].target=ACCEPT";

  # icmp-wan-out
  uci "add firewall rule";
  #uci "set firewall.\@rule[-1].name=icmp-wan-out";
  uci "set firewall.\@rule[-1].dest=wan";
  uci "set firewall.\@rule[-1].proto=icmp";
  uci "set firewall.\@rule[-1].target=ACCEPT";

  # ssh-wan-out
  uci "add firewall rule";
  #uci "set firewall.\@rule[-1].name=ssh-wan-out";
  uci "set firewall.\@rule[-1].dest=wan";
  uci "set firewall.\@rule[-1].proto=tcp";
  uci "set firewall.\@rule[-1].dest_port=22";
  uci "set firewall.\@rule[-1].target=ACCEPT";

  # syslog-wan/lan-out
  for (qw/wan lan/) {
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=syslog-$_-out";
    uci "set firewall.\@rule[-1].dest=\'$_\'";
    uci "set firewall.\@rule[-1].proto=udp";
    uci "set firewall.\@rule[-1].dest_ip=\'$p->{log_ip}\'";
    uci "set firewall.\@rule[-1].dest_port=514";
    uci "set firewall.\@rule[-1].target=ACCEPT";
  }

  # ntp-lan-out
  uci "add firewall rule";
  #uci "set firewall.\@rule[-1].name=ntp-lan-out";
  uci "set firewall.\@rule[-1].dest=lan";
  uci "set firewall.\@rule[-1].proto=udp";
  uci "set firewall.\@rule[-1].dest_ip=\'$p->{ntp_ip}\'";
  uci "set firewall.\@rule[-1].dest_port=123";
  uci "set firewall.\@rule[-1].target=ACCEPT";

  # snmp-lan-in
  uci "add firewall rule";
  #uci "set firewall.\@rule[-1].name=snmp-lan-in";
  uci "set firewall.\@rule[-1].src=lan";
  uci "set firewall.\@rule[-1].proto=udp";
  uci "set firewall.\@rule[-1].dest_port=161";
  uci "set firewall.\@rule[-1].target=ACCEPT";

  # opkg-lan-out
  uci "add firewall rule";
  #uci "set firewall.\@rule[-1].name=opkg-lan-out";
  uci "set firewall.\@rule[-1].dest=lan";
  uci "set firewall.\@rule[-1].dest_ip=\'10.15.0.3\'";
  uci "set firewall.\@rule[-1].proto=tcp";
  uci "set firewall.\@rule[-1].dest_port=80";
  uci "set firewall.\@rule[-1].target=ACCEPT";

  #####
  my @outgoing_rules_ip_list;
  recursive_search_by_from_hostname(\@outgoing_rules_ip_list, $p->{tun_node_name},
    $p->{tun_array_ref}, $p->{tun_node_name});
  #say 'Outgoing: ', Dumper \@outgoing_rules_ip_list;

  my @incoming_rules_ip_list;
  recursive_search_by_to_hostname(\@incoming_rules_ip_list, $p->{tun_node_name},
    $p->{tun_array_ref}, $p->{tun_node_name});
  #say 'Incoming: ', Dumper \@incoming_rules_ip_list;

  # build outgoing tinc rules
  foreach (@outgoing_rules_ip_list) {
    # tinc-outgoing-wan-in-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'tinc-outgoing-wan-in-$_\'";
    uci "set firewall.\@rule[-1].src=wan";
    uci "set firewall.\@rule[-1].proto=tcpudp";
    uci "set firewall.\@rule[-1].src_ip=\'$_\'";
    uci "set firewall.\@rule[-1].src_port=655";
    uci "set firewall.\@rule[-1].family=ipv4";
    uci "set firewall.\@rule[-1].target=ACCEPT";
    # tinc-outgoing-wan-out-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'tinc-outgoing-wan-out-$_\'";
    uci "set firewall.\@rule[-1].dest=wan";
    uci "set firewall.\@rule[-1].proto=tcpudp";
    uci "set firewall.\@rule[-1].dest_ip=\'$_\'";
    uci "set firewall.\@rule[-1].dest_port=655";
    uci "set firewall.\@rule[-1].family=ipv4";
    uci "set firewall.\@rule[-1].target=ACCEPT";
  }
  # build incoming tinc rules
  foreach (@incoming_rules_ip_list) {
    # tinc-incoming-wan-in-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'tinc-incoming-wan-in-$_\'";
    uci "set firewall.\@rule[-1].src=wan";
    uci "set firewall.\@rule[-1].proto=tcpudp";
    uci "set firewall.\@rule[-1].src_ip=\'$_\'";
    uci "set firewall.\@rule[-1].dest_port=655";
    uci "set firewall.\@rule[-1].family=ipv4";
    uci "set firewall.\@rule[-1].target=ACCEPT";
    # tinc-incoming-wan-out-xxx
    uci "add firewall rule";
    #uci "set firewall.\@rule[-1].name=\'tinc-incoming-wan-out-$_\'";
    uci "set firewall.\@rule[-1].dest=wan";
    uci "set firewall.\@rule[-1].proto=tcpudp";
    uci "set firewall.\@rule[-1].dest_ip=\'$_\'";
    uci "set firewall.\@rule[-1].src_port=655";
    uci "set firewall.\@rule[-1].family=ipv4";
    uci "set firewall.\@rule[-1].target=ACCEPT";
  }

  my @hacks_restore_list = qw/pf_input_ipsec pf_rsyslog_forwarding pf_admin_access_des
    pf_clients_forwarding pf_internet_r2d2/;

  for (@hacks_restore_list) {
    uci "add firewall include";
    uci "set firewall.\@include[-1].type=restore";
    uci "set firewall.\@include[-1].path=\'/etc/firewall.user_${_}\'";
    uci "set firewall.\@include[-1].family=ipv4";
  }

  # include r2d2 clients file
  uci "add firewall include";
  uci "set firewall.\@include[-1].type=restore";
  uci "set firewall.\@include[-1].path=\'/var/r2d2/firewall.clients\'";
  uci "set firewall.\@include[-1].family=ipv4";

  uci "add firewall include";
  uci "set firewall.\@include[-1].path=\'/etc/firewall.user\'";

  uci "add firewall include";
  uci "set firewall.\@include[-1].path=\'/etc/tc.user\'";

  #uci "show firewall";
  uci "commit firewall";
  insert_autogen_comment '/etc/config/firewall';

  # save iptables_restore hacks to firewall.user_xxx files
  for (@hacks_restore_list) {
    my $h = $p->{hacks}{$_};
    file("/etc/firewall.user_$_",
      owner => "ural",
      group => "root",
      mode => 644,
      content => $h,
      on_change => sub {
	say "Hack $_ was added to /etc/firewall.user_$_.";
      }
    ) if $h;
  }

  my $firewall_user_file = '/etc/firewall.user';
  file $firewall_user_file,
    owner => "ural",
    group => "root",
    mode => 644,
    content => template("files/firewall.user.0.tpl");

  # append hacks to firewall.user
  for (qw/pf_interfaces_names 
    pf_snat_config pf_dnat_config pf_internet_forwarding pf_ban_in_logs/) {
    my $h = $p->{hacks}{$_};
    append_if_no_such_line($firewall_user_file,
      line => $h,
      on_change => sub {
	say "Hack $_ was added to /etc/firewall.user.";
      }
    ) if $h;
  }

  my $tc_user_file = '/etc/tc.user';
  file $tc_user_file,
    owner => "ural",
    group => "root",
    mode => 644,
    content => template("files/tc.user.0.tpl");

  # append hacks to tc.user
  for (qw/tc_lan_config tc_wan_config/) {
    my $h = $p->{hacks}{$_};
    append_if_no_such_line($tc_user_file,
      line => $h,
      on_change => sub {
	say "Hack $_ was added to /etc/tc.user.";
      }
    ) if $h;
  }

  say 'Firewall configuration finished for '.$p->get_host;
};


desc "Erebus router: Configure r2d2";
# --confhost=erebus or empty is allowed
task "conf_r2d2", sub {
  my $ch = shift->{confhost} || 'erebus';
  my $p = read_db($ch);
  check_par;

  say 'R2d2 configuration started for '.$p->get_host;

  for (qw/perl perlbase-encode perlbase-findbin perl-dbi perl-dbd-mysql perl-netaddr-ip perl-sys-runalone libmariadb/) {
    pkg $_, ensure => "present";
  }

  file "/etc/r2d2",
    owner => "ural",
    group => "root",
    mode => 755,
    ensure => "directory";

  for (qw/rtsyn print_rules/) {
    file "/etc/r2d2/$_",
      owner => "ural",
      group => "root",
      mode => 755,
      source => "files/r2d2/$_",
      on_change => sub { say "$_ installed." };
  }

  file '/etc/r2d2/r2d2.conf',
    owner => "ural",
    group => "root",
    mode => 644,
    source => "files/r2d2/r2d2.conf",
    on_change => sub { say "r2d2.conf installed." };

  host_entry 'bikini.uwc.local',
    ensure => 'present',
    ip => '10.15.0.3',
    on_change => sub { say "Control server address added to /etc/hosts." };

  cron_entry 'rtsyn',
    ensure => 'present',
    command => "/etc/r2d2/rtsyn 1> /dev/null",
    user => 'ural',
    minute => '1,31',
    hour => '*',
    on_change => sub { say "cron entry for rtsyn created." };

  #my @crons = cron list => "ural"; say Dumper(\@crons);

  # run rtsyn after every reboot
  delete_lines_matching '/etc/rc.local', 'exit 0';
  append_if_no_such_line '/etc/rc.local',
    "(sleep 10 && logger 'Starting rtsyn ater reboot' && /etc/r2d2/rtsyn >/dev/null)&",
    on_change => sub { say "rc.local line to run rtsyn on reboot added." };
  append_if_no_such_line '/etc/rc.local', 'exit 0';

  say 'R2d2 configuration finished for '.$p->get_host;
};


desc "Erebus router: Configure snmp";
# --confhost=erebus or empty is allowed
task "conf_snmp", sub {
  my $ch = shift->{confhost} || 'erebus';
  my $p = read_db($ch);
  check_par;

  say 'Snmp configuration started for '.$p->get_host;

  pkg 'snmpd', ensure => 'present';

  file "/etc/config/snmpd",
    owner => "ural",
    group => "root",
    mode => 644,
    content => template('files/snmpd.0.tpl', _hostname=>$p->get_host),
    on_change => sub { say "/etc/config/snmpd installed." };

  say 'Snmp configuration finished for '.$p->get_host;
};


##################################
desc "Erebus router: Test firewall hacks";
task "test_firewall_hacks", sub {
  my $p = read_db 'erebus';
  check_par;

  say 'Firewall hacks test started for '.$p->get_host;
  my $err = undef;

  my @hacks_restore_list = qw/pf_input_ipsec pf_rsyslog_forwarding pf_admin_access_des
    pf_clients_forwarding pf_internet_r2d2/;

  for (@hacks_restore_list) {
    say "* Testing hack: $_";
    my $h = $p->{hacks}{$_};
    if ($h) {
      my $fn = '/tmp/testhack.tmp';
      my $f = undef;
      file($fn,
	content => $h, 
	on_change => sub { $f = 1 }
      );
      say "ERROR! Temporary file is not created! This is subject for detailed investigation." unless $f;

      my $output = run "/usr/sbin/iptables-restore --noflush --test < $fn", timeout => 100;
      say $output if $output;
      if ($? > 0) { $err = 1 }
      if ($? == 0) {
	say "OK, result: $?.";
      } elsif ($? == 1) {
	say "ERROR, result: $?, hack contents format error.";
      } elsif ($? == 2) {
	say "ERROR, result: $?, iptables rule or chain error.";
      } else {
	say "ERROR, result: $?, unspecified error.";
      }

      unlink($fn);
    } else {
      say "WARNING! Hack contents is empty. It will be simply ignored.";
    }
    say;
  }

  say 'Firewall hacks test finished for '.$p->get_host;
  die "\nERRORS found!!! Fix it before applying firewall configuration.\n" if $err;
  0;
};


##################################
desc "Erebus router: restart firewall (useful after updating firewall hacks)";
task "restart_firewall", sub {
  say "Restarting firewall on host ".connection->server." ...";
  #service firewall => 'restart';
  my $output = run "/etc/init.d/firewall restart 2>&1", timeout => 100;
  say $output if $output;
  return (($? > 0) ? 255:0);
};

desc "Erebus router: restart ipsec";
task "restart_ipsec", sub {
  say "Restarting strongswan on host ".connection->server." ...";
  #service ipsec => 'restart';
  my $output = run "/etc/init.d/ipsec restart 2>&1", timeout => 100;
  say $output if $output;
  return (($? > 0) ? 255:0);
};

desc "Erebus router: reload ipsec (useful after updating strongswan_config hack)";
task "reload_ipsec", sub {
  say "Reloading strongswan configuration on host ".connection->server." ...";
  #service ipsec => 'reload';
  my $output = run "/etc/init.d/ipsec reload 2>&1", timeout => 100;
  say $output if $output;
  return (($? > 0) ? 255:0);
};

desc "Erebus router: reload network (useful after updating routes or dhcp)";
task "reload_network", sub {
  say "Reloading network configuration on host ".connection->server." ...";
  #service network => 'reload';
  my $output = run "/etc/init.d/network reload 2>&1", timeout => 100;
  say $output if $output;
  return (($? > 0) ? 255:0);
};


##################################
task "_t", sub {
  my $p = read_db 'erebus';
  check_par;
  $p->dump;
}, {dont_register => TRUE};

1;

=pod

=head1 NAME

$::module_name - {{ SHORT DESCRIPTION }}

=head1 DESCRIPTION

{{ LONG DESCRIPTION }}

=head1 USAGE

{{ USAGE DESCRIPTION }}

 include qw/Deploy::Erebus/;

 task yourtask => sub {
    Deploy::Erebus::example();
 };

=head1 TASKS

=over 4

=item example

This is an example Task. This task just output's the uptime of the system.

=back

=cut
